# -*- coding: utf-8 -*-
"""assignment6_template.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RDsnQTMw7wsyV71h84f4488MGsUi4-fe
"""

grading = False

"""
assignment6_template.ipynb

"""

from IPython import get_ipython
!jupyter nbconvert --to script assignment6_template.ipynb

import os
from functools import reduce

import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
from pandas.util.testing import assert_frame_equal

class Villain(object):
    def __init__(self, name, captured, rank):
        """
        :param name: The name, a string.
        :param captured: The captivity status, a boolean.
        :param rank: The rank, an integer.
        """
        self.name = name
        self.captured = captured
        self.rank = rank
        
    def __str__(self):
        return f"Villain: {self.name}, Captured: {self.captured}, Rank: {self.rank}"

    #########################################
    # IMPLEMENT THE COMPARISON METHODS HERE #
    #########################################

    def __bool__(self):
      return self.captured

    def __eq__(self, other):
      return self.rank == other.rank
    def __ne__(self, other):
      return self.rank != other.rank
    def __lt__(self, other):
      return self.rank < other.rank
    def __gt__(self, other):
      return self.rank > other.rank
    def __le__(self, other):
      return self.rank <= other.rank
    def __ge__(self, other):
      return self.rank >= other.rank

villains = [
    Villain("Riddler", True, 3),
    Villain("Scarecrow", True, 10),
    Villain("Penguin", True, 6),
    Villain("Joker", False, 1),
    Villain("Calendar Man", False, 8),
    Villain("Bane", False, 5)
]

def captured_villains(villains):
    """
    Task 1a)

    !!! DO NOT CHANGE THIS METHOD. !!!

    You need to write code in the Villain class to solve this.
    You can find the method you need here: https://docs.python.org/3/reference/datamodel.html#special-method-names
    :return: A list of captured villains.
    """
    return [str(x) for x in villains if x]

# Correct output:
# Villain: Riddler, Captured: True, Rank: 3
# Villain: Scarecrow, Captured: True, Rank: 10
# Villain: Penguin, Captured: True, Rank: 6
if not grading:
    print("\n".join(captured_villains(villains)))

def villains_by_rank(villains):
    """
    Task 1b)

    !!! DO NOT CHANGE THIS METHOD. !!!

    You need to write code in the Villain class to solve this.
    You need to implement ALL SIX of the rich comparison methods.
    You can find them here: https://docs.python.org/3/reference/datamodel.html#special-method-names

    The villains must be ordered by their rank.

    HINT: If you have implemented the methods correctly, the following should be possible:
    villain1 < villain2
    villain1 <= villain2
    villain1 == villain2
    villain1 != villain2
    villain1 > villain2
    villain1 >= villain2
    where each comparison uses the rank of the villains for the comparison.

    :return: A list of the string representation of Villains, sorted by their rank (ascending).
    """
    return [str(x) for x in sorted(villains)]

# Correct output:
# Villain: Joker, Captured: False, Rank: 1
# Villain: Riddler, Captured: True, Rank: 3
# Villain: Bane, Captured: False, Rank: 5
# Villain: Penguin, Captured: True, Rank: 6
# Villain: Calendar Man, Captured: False, Rank: 8
# Villain: Scarecrow, Captured: True, Rank: 10



if not grading:
    print("\n".join(villains_by_rank(villains)))

def clean(unclean):
    """
    Task 2a)

    "Cleans" the self.unclean list.
    You need to return a list containing all the numbers in self.unclean by using a list comprehension.

    --> Implement this method in ONE line. <--

    Use list comprehensions for this task: https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions

    HINT: Use type() as an "if" condition in the list comprehension to create a new list containing only the
    integers.

    :return: A new (!) list containing only the integers in self.unclean .
    """
    return [x for x in unclean if isinstance(x,int) ]  # either delete or replace this line with your solution

unclean = [1, 2, 3, "Dust", 4, "Grime", 5, "Cobwebs"]
# Correct output:
# [1, 2, 3, 4, 5]
if not grading:
    print(clean(unclean))

def check_todo(cleaning_status):
    """
    Task 2b)

    Checks which items still have to be cleaned and returns a list containing those items.

    The structure is as follows:
        [
            (item1, status),
            (item2, status),
            ...
        ]
    The "status" describes whether or not the item is cleaned.
    You have to return a list containing all the items that are not cleaned, and ONLY those items, NOT their status!

    --> Implement this method in ONE line. <--

    Use a list comprehension for this task: https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions

    HINT: You can unpack tuples in for loops (use Google to find out how, maybe you already know how to do it) or
    you can iterate over the list of tuples and access the tuple elements by their index.

    :return: A list containing the unfinished items from the todo list.
    """
    return [x[0] for x in cleaning_status if not x[1] ]  # either delete or replace this line with your solution

cleaning_status = [("Cups", True), ("Windows", False), ("Shoes", True)]
# Correct output:
# ['Windows']
if not grading:
    print(check_todo(cleaning_status))

def check_bills(bills):
    """
    Task 2c)

    Calculates how much the total cost of the bills are.

    You can find the list of bills in self.bills .

    --> Implement this method in ONE line. <--

    !!! Use reduce() to solve this task! https://docs.python.org/3/library/functools.html#functools.reduce !!!
    Do NOT use sum() or anything like that. You MUST use reduce() !

    :return: The total amount of bills to be paid.
    """
    # Set initializer (optional) to 0 in case an empty list is passed into function!
    return reduce(lambda x, y: x + y, bills, 0)  # either delete or replace this line with your solution

bills = [100, 300, 125.30, 10000]
# Correct output:
# 10525.3


if not grading:
    print(check_bills(bills))

def convert2float(t):
    """
    Task 3a)

    Converts an iterable (tuples, lists, ...) to a tuple of floats.
    You may assume that the conversion to float never fails, you don't need to check the input for validity
    or implement exception handling.
    NOTE: This does not mean you can ignore exceptions! It means the input will never be structured in such a way
    that an exception can occur - if you get an exception then your code is incorrect.

    --> Implement this method in ONE line. <--

    HINT: Use map(): https://docs.python.org/3/library/functions.html#map

    :param t: An iterable.
    :return: A tuple containing the values of "t", converted to float.
    """
    return tuple(map(lambda x: float(x), t))  # either delete or replace this line with your solution

t = ["1", "2", "3"]
t = convert2float(t)
# Correct output:
# (1.0, 2.0, 3.0)
if not grading:
    print(t)

def load_coordinates():
    """
    Task 3b)

    Loads the scrambled coordinates.

    Store the coordinates in a pandas DataFrame: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html
    The DataFrame must have two columns: "x" and "y".

    Each line contains one set of coordinates. The first value is the x-coordinate, the second value is
    the y-coordinate.
    You first need to split each line into two strings, where each of the strings represents either the x-coordinate
    or the y-coordinate.

    Use convert2float() from above to convert the coordinates to floats.
    NOTE: convert2float() takes an iterable as input. Strings are iterable!

    --> Make sure to convert the ENTIRE coordinate, NOT just the individual digits! <--

    Then create a DataFrame containing two columns: "x" and "y", containing the x-coordinates in the "x" column
    and the y-coordinates in the "y" column.
    
    :return: A DataFrame containing the coordinates.
    """

    
    with open(os.path.join("scrambled_coordinates.txt"), "r") as f:
        lines = f.readlines()
        
    ##################
    # YOUR CODE HERE #
    ##################
    
    #convert the two coordinates in each line to a float
    coordinates = [convert2float(line.split()) for line in lines]
    
    
    #coordinatesX = [coordinate[0] for coordinate in coordinates] #take the first (x-coordinate) element of each element in coordinates
    #coordinatesY = [coordinate[1] for coordinate in coordinates] #take the second (y-coordinate) element of each element in coordinates
    #d = {'x': coordinatesX, 'y': coordinatesY}

    df = pd.DataFrame(coordinates, columns = ['x','y'])
    
    return df

df = load_coordinates()
correct_3b = pd.read_csv("3b_data.csv")
# If you see no error message everything is correct.
if not grading:
    pd.util.testing.assert_frame_equal(df, correct_3b)

def fix_symbol(df):
    """
    Task 4)

    You need to fix the corrupted coordinates data in this method.
    To fix the data you need to iterate over the rows in the DataFrame and perform the following operations:
        - if the x-coordinate value is >= 0, multiply it by itself
        - if the row index is an even number, multiply both the x-coordinate and the y-coordinate by -1
            (multiply it with the number "minus one")
        - divide the y-coordinate by the x-coordinate
        - divide the x-coordinate by the y-coordinate
            NOTE: Do this AFTER you divide the y-coordinate by the x-coordinate, don't use the old y-coordinate
            value for this. Use the value you get after you divide the y-coordinate by the x-coordinate.
        - swap the x and y-coordinates
    !!! You must perform these steps in the exact order outlined above! !!!
    For example, the swapping must always be the FINAL step for each row.

    :param df: The DataFrame containing the coordinates.
    :return: A DataFrame with the fixed coordinates.
    """
    ##################
    # YOUR CODE HERE #
    ##################
    
    #Do every operation in a seperate iteration with df.apply()
    """
    df['x'] = df['x'].apply(lambda x: x*x if x>=0 else x) #multiply x with x if x>=0
    df[df.index % 2 == 0] = df[df.index % 2 == 0].apply(lambda x: x * -1) #multiply by -1 if index % 2 == 0
    df['y'] = df['y']/df['x'] #divide y by x
    df['x'] = df['x']/df['y'] #divide x by y


    # exchange x-column with y-column
    temp = df['x'].copy()
    df['x'] = df['y']
    df['y'] = temp
    """
    
    for index, row in df.iterrows():
      
      #first operation
      row.x = row.x**2 if row.x >= 0 else row.x
      
      #second operation
      row.x = row.x*-1 if ((index % 2) == 0) else row.x
      row.y = row.y*-1 if ((index % 2) == 0) else row.y

      #third operation
      
      row.y = row.y/row.x

      #forth operation
      
      row.x = row.x/row.y

      #fifth operation
      temp = row.x
      row.x = row.y
      row.y = temp


    return df

def plot_df(df):
    """
    !!! DO NOT CHANGE THIS METHOD. !!!

    Plots the coordinates contained in the DataFrame.

    :param df: The DataFrame containing the coordinates.
    """
    ax1 = df.plot.scatter(x="x", y="y", color="yellow")
    ax1.set_facecolor("black")
    plt.show()

# Output of the corrupted data
correct_3b = pd.read_csv("3b_data.csv")
if not grading:
    plot_df(correct_3b)

correct_3b = pd.read_csv("3b_data.csv")
# you need to implement this before running this cell
# if implemented correctly, you will see a symbol
if not grading:
    df = fix_symbol(correct_3b)
    plot_df(df)

def superhero_data(percentile, df=None):
    """
    Task 5)

    Plots the data of the superheroes whose strength is in the lower percentile, for a given percentile.

    You must load the file "SuperheroDataset.csv" into a DataFrame.
    Then calculate the specified quantile for the "Strength" column.
    HINT: There is a function in pandas you can use for this.
    Example: 0.1 would indicate the 10% percentile. This is the value for "Strength" for which 10% of the
    superheroes are below the rest, i.e. the 10% weakest superheroes.

    !!! Do not forget to calculate the superheroes whose Strength level is are BELOW the percentile value. !!!

    Then, for those superheroes, plot their Intelligence, Speed and Power as a bar chart.
    Additionally:
        - use the Name for the x-axis
        - rotate the Name so it is readable from left to right (the default will be from bottom to top)
        - set the figure size to be 1000x700 pixels
        - change the colormap of the graph. You can find valid colormaps here: https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html

    :param percentile: The percentile.
    :param df: Optional. If passed, this DataFrame will be used instead. Intended to be used if the percentile
        calculation can't be solved.
    """
    ##################
    # YOUR CODE HERE #
    ##################

    
    data = pd.read_csv("SuperheroDataset.csv")
    quant = data.Strength.quantile(percentile)

    



    #find every element that has strength < than quant
    weakSuperHeros = data[ data.Strength < quant ]
    
    
    my_dpi=100
    plt.rcParams["figure.dpi"] = my_dpi
    
    #We could even preset the figure size for all matplot figures
    #plt.rcParams["figure.figsize"] = 1000/my_dpi, 700/my_dpi


    plot = weakSuperHeros.plot.bar(y=['Intelligence','Speed','Power'], x='Name', colormap = 'coolwarm', rot=0, figsize=(1000/my_dpi, 700/my_dpi))
    
    #in case we want to save the file -> uncomment
    #plt.savefig('/plot.png')
    




    # Has not necessarily to be called since we plot using pandas
    plt.show()

df = None
# df = pd.read_pickle("task5.pkl")  # uncomment this if you cant solve the percentile calculation
superhero_data(0.1, df=df)
if not grading:
    superhero_data(0.1)